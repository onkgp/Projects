# pylint: disable=C0103
# pylint: disable=C0301

'''
파이썬은 C언어나 JAVA와 다르게 변수에 저장된 값을 스스로 판단하여 자료형을 알아낸다
    [변수명 = 변수에 저장할 값]

- 파이썬에서 사용하는 변수는 객체를 가리킨다.
- 객체란 자료형을 포함해 파이썬에서 사용되는 모든 것을 뜻한다.
'''

a = 3
'''
- 3이라는 값을 가지는 정수 자료형(객체)이 자동으로 메모리에 생성된다
- a는 변수의 이름이며 3이라는 정수형 객체가 저장된 메모리 위치를 가리킨다
- 즉, 변수 a는 객체가 저장된 메모리의 위치를 가리키는 레퍼런스(Reference)라고 할 수 있다
'''

print(type(3))
print(a.real)
'''
- type()은 입력받은 객체의 자료형이 무엇인지 알려주는 함수다. 3은 정수int(integer)형 객체라는 것을 확인할 수 있다
- 파이썬의 모든 자료형은 객체라서 3은 상수값이 아닌 하나의 "정수형 객체"다
- 따라서 a = 3과 같이 선언하면 a.real처럼 내장 함수를 사용할 수 있다
'''

a = 3
b = 3
print(a is b)
'''
- a와 b 모두 같은 객체인 3을 가리킨다
- 3이라는 정수형 객체를 가리키는 변수가 2개다(Reference Count 즉, 참조 개수가 2라고 표현할 수 있다). 이 두 변수는 가리키는 대상이 같다. 
- 따라서 같은 객체를 가리키고 있는지 판단하는 내장 함수인 x is y를 실행했을 때 True를 리턴한다
'''

# 자료형에 대한 참조 개수를 알려주는 sys.getrefcount라는 함수를 이용해서 3280이라는 정수형 객체에 참조 개수가 몇 개인지 확인
import sys
print(sys.getrefcount(3280))

a = 3280
print(sys.getrefcount(3280)) #a변수 사용으로 참조개수가 3으로 늘어난 것을 확인할 수 있음

b = 3280
print(sys.getrefcount(3280)) #b변수 사용으로 참조개수가 4로 늘어난 것을 확인할 수 있음

c = 3280
print(sys.getrefcount(3280)) #c변수 사용으로 참조개수가 5로 늘어난 것을 확인할 수 있음


# 변수를 만드는 여러 가지 방법
a, b = ('python', 'life') #튜플로 a, b에 값을 대입할 수 있다.
print(a, b)
(a, b) = 'python', 'life' #튜플은 괄호를 생략해도 된다
print(a, b)
[a, b] = ['python', 'life'] #리스트로 변수를 만들 수도 있다
print(a, b)

a = b = 'python' #여러개의 변수에 같은 값을 대입할 수 있다
print(a, b)

a = 3
b = 5
a, b = b, a
print(a) #a는 처음에 3이였지만 a를 b로 대입하여 결과값은 5가 출력된다.
print(b) #b는 처음에 5였지만 b를 a로 대입하여 결과값은 3이 출력된다.

# 메모리에 생성된 변수 없애기(Garbage Collection, 쓰레기 수집)
a = 3
b = 3
del(a)
del(b)
'''
변수 a와 b가 3이라는 객체를 가리켰다가 del이라는 내장 함수에 의해서 사라진다. 
따라서 레퍼런스 카운트가 0이 되어 정수형 객체 3도 메모리에서 사라지게 된다. 
※ 사용한 변수를 del명령어를 이용해 일일이 삭제할 필요는 없다. 파이썬이 이 모든 것을 자동으로 처리해줌
'''

# 리스트를 변수에 넣고 복사하고자 할 때
a = [1, 2, 3]
b = a
a[1] = 4
print(a)
print(b)
'''
a리스트의 1번 요소를 변경하니 b리스트도 변경되었다.(출력값이 같다.) 
그 이유는 a, b의 변수명만 다를 뿐이지 모두 같은 리스트를 가르키고 있기 때문이다.
'''
# [:] 이용해서 리스트 복사
a = [1, 2, 3]
b = a[:]
a[1] = 4
print(a)
print(b) #a리스트 값을 변경해도 b리스트에 영향을 끼치지 않는다.

# Copy 모듈 이용
from copy import copy #Copy 함수 사용
a = [4, 5, 6]
b = copy(a)
print(a)
print(b)
print(b is a) #False를 리턴하는 이유는 b와 a가 값은 같지만 서로 다른 객체이기 때문이다
